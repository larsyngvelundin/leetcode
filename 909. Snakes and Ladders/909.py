test_cases = [
    [[-1, -1, -1, 16, -1, -1, -1, -1, 37, -1],
     [-1, -1, 87, -1, -1, -1, -1, -1, -1, 16],
     [-1, 53, 75, 70, -1, -1, -1, -1, -1, -1],
     [-1, -1, -1, -1, -1, 42, -1, -1, 75, 50],
     [-1, -1, -1, -1, 35, -1, 12, -1, -1, -1],
     [56, -1, -1, -1, -1, 95, -1, -1, -1, -1],
     [-1, -1, -1, -1, 95, -1, -1, -1, 32, 87],
     [-1, 47, 35, -1, -1, -1, -1, -1, -1, -1],
     [-1, -1, -1, -1, -1, 35, -1, -1, 55, 83],
     [-1, -1, -1, 28, -1, -1, -1, 2, -1, -1]],
    [[-1, -1, -1, -1, -1, -1, 115, -1, -1, -1, -1, 169, 130, 187, -1],
        [-1, -1, 120, -1, -1, 6, 40, -1, 161, -1, -1, -1, -1, 30, 57],
        [-1, 46, 102, -1, -1, 196, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, 95],
        [-1, -1, 174, -1, -1, -1, -1, 49, -1, 178, 95, -1, -1, 110, -1],
        [69, -1, -1, -1, 14, 118, -1, -1, 157, -1, 60, -1, -1, 204, -1],
        [176, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [203, -1, -1, 174, -1, -1, -1, -1, -1, -1, -1, -1, 86, -1, 73],
        [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [-1, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, 98, -1, -1, 51],
        [161, -1, -1, -1, -1, -1, -1, -1, 98, 192, -1, 91, -1, -1, -1],
        [194, -1, 106, 14, -1, 187, -1, 216, -1, -1, 42, -1, -1, -1, -1],
        [63, -1, -1, -1, 87, -1, -1, -1, -1, 78, -1, -1, 62, 5, 5],
        [-1, -1, 42, 175, -1, -1, -1, -1, 51, -1, -1, 87, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, 160, -1, -1, 94, -1, -1, -1, -1, -1]],
    [[-1, 17, -1, 6, -1, -1],
        [-1, 23, -1, 31, -1, -1],
        [-1, 35, -1, 28, -1, -1],
        [-1, 30, 24, -1, 13, -1],
        [-1, 10, -1, 16, 26, -1],
        [-1, -1, 27, 15, -1, -1]],
    [[-1, -1, 128, -1, -1, -1, 136, -1, -1, -1, 109, -1],
        [-1, -1, -1, -1, -1, 103, -1, -1, 56, 10, -1, -1],
        [-1, -1, -1, -1, -1, -1, 116, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1, 50, -1, 67, 107],
        [-1, 40, -1, -1, -1, 20, -1, 59, -1, 67, -1, -1],
        [-1, -1, -1, -1, -1, -1, 112, 133, 111, -1, -1, -1],
        [-1, -1, 112, -1, 74, -1, -1, -1, -1, -1, -1, -1],
        [23, -1, 115, -1, 129, 126, -1, -1, -1, -1, -1, -1],
        [106, 143, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1, 26, 102, 1, 29],
        [26, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]],
    [[-1, -1, 27, 13, -1, 25, -1],
        [-1, -1, -1, -1, -1, -1, -1],
        [44, -1, 8, -1, -1, 2, -1],
        [-1, 30, -1, -1, -1, -1, -1],
        [3, -1, 20, -1, 46, 6, -1],
        [-1, -1, -1, -1, -1, -1, 29],
        [-1, 29, 21, 33, -1, -1, -1]],
    [[-1, -1, 19, 10, -1],
        [2, -1, -1, 6, -1],
        [-1, 17, -1, 19, -1],
        [25, -1, 20, -1, -1],
        [-1, -1, -1, -1, 15]],
    [[1, 1, -1],
        [1, 1, 1],
        [-1, 1, 1]],
    [[-1, -1, -1],
        [-1, 9, 8],
        [-1, 8, 9]],
    [[-1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1],
        [-1, 35, -1, -1, 13, -1],
        [-1, -1, -1, -1, -1, -1],
        [-1, 15, -1, -1, -1, -1]],
    [[-1, -1], [-1, 3]]
]
expected_results = [4, 7, 3, 8, 4, 2, -1, 1, 4, 1]


def snakesAndLadders(board):
    space_list = []
    for i in reversed(range(0, len(board))):
        if i % 2 != len(board) % 2:
            for j in range(0, len(board[i])):
                space_list.append(board[i][j])
        else:
            for j in reversed(range(0, len(board[i]))):
                space_list.append(board[i][j])

    for i in range(0, len(space_list)):
        if space_list[i] > 0:
            space_list[i] -= 1
        else:
            space_list[i] = i

    move_amount = 0
    current_pos = 0
    goal_pos = len(space_list) - 1
    steps_to_goal = 9999
    solvable = True
    while current_pos < goal_pos and solvable:
        move_amount += 1
        highest_value = 0
        highest_value_index = 0
        one_step_highest_value = 0
        one_step_highest_value_index = 0
        two_step_highest_value = 0
        check_range = get_range(current_pos, goal_pos)
        for i in reversed(range(current_pos + 1, current_pos+check_range)):
            if space_list[i] >= one_step_highest_value:
                one_step_highest_value = space_list[i]
                one_step_highest_value_index = i
                if space_list[i] >= highest_value:
                    highest_value = space_list[i]
                    highest_value_index = i
                if i == goal_pos:
                    steps_to_goal = 1
            if steps_to_goal > 1:
                check_range_level_2 = get_range(space_list[i], goal_pos)
                for j in reversed(range(space_list[i] + 1, space_list[i] + check_range_level_2)):
                    if space_list[j] >= highest_value and space_list[j] > one_step_highest_value:
                        highest_value = space_list[j]
                        highest_value_index = i
                    if space_list[i] != space_list[j] and steps_to_goal > 2:
                        if space_list[j] > two_step_highest_value:
                            two_step_highest_value = space_list[j]
                        check_range_level_3 = get_range(
                            space_list[j], goal_pos)
                        for y in reversed(range(space_list[j] + 1, space_list[j] + check_range_level_3)):
                            if space_list[y] > highest_value and space_list[y] > one_step_highest_value:
                                highest_value = space_list[y]
                                highest_value_index = i
                            if space_list[y] < goal_pos:
                                check_range_level_4 = get_range(
                                    space_list[y], goal_pos)
                                for x in reversed(range(space_list[y] + 1, space_list[y] + check_range_level_4)):

                                    if space_list[x] > highest_value and space_list[i] != space_list[j] and space_list[y] != space_list[j] and space_list[y] != space_list[x]:
                                        # print("test")
                                        # print(space_list[x])
                                        highest_value = space_list[x]
                                        highest_value_index = i
                                    if space_list[x] < goal_pos:
                                        check_range_level_5 = get_range(
                                            space_list[x], goal_pos)
                                        for z in reversed(range(space_list[y] + 1, space_list[y] + check_range_level_4)):

                                            if space_list[z] > highest_value and space_list[i] != space_list[j] and space_list[y] != space_list[j] and space_list[y] != space_list[x]:
                                                highest_value = space_list[z]
                                                highest_value_index = i
                                            if space_list[z] < goal_pos:
                                                check_range_level_6 = get_range(
                                                    space_list[z], goal_pos)
                                                for z2 in reversed(range(space_list[z] + 1, space_list[z] + check_range_level_6)):
                                                    if space_list[z2] > highest_value and space_list[i] != space_list[j] and space_list[y] != space_list[j] and space_list[y] != space_list[x] and space_list[z] != space_list[x]:
                                                        highest_value = space_list[z2]
                                                        highest_value_index = i
                                            elif one_step_highest_value < goal_pos and two_step_highest_value < goal_pos and highest_value < goal_pos:
                                                highest_value = goal_pos
                                                highest_value_index = i
                                    elif one_step_highest_value < goal_pos and two_step_highest_value < goal_pos and highest_value < goal_pos:
                                        highest_value = goal_pos
                                        highest_value_index = i

                            elif one_step_highest_value < goal_pos and two_step_highest_value < goal_pos:
                                highest_value = goal_pos
                                highest_value_index = i

        if two_step_highest_value <= one_step_highest_value and goal_pos - current_pos > 6 and two_step_highest_value <= 6:
            solvable = False
        current_pos = space_list[highest_value_index]
        if one_step_highest_value > highest_value:
            current_pos = space_list[one_step_highest_value_index]
    if solvable:
        return move_amount
    else:
        return -1


def snakesAndLaddersRework(board):
    steps_away = {}
    space_list = []
    for i in reversed(range(0, len(board))):
        if i % 2 != len(board) % 2:
            for j in range(0, len(board[i])):
                space_list.append(board[i][j])
        else:
            for j in reversed(range(0, len(board[i]))):
                space_list.append(board[i][j])

    for i in range(0, len(space_list)):
        steps_away[i] = -1
        if space_list[i] > 0:
            space_list[i] -= 1
        else:
            space_list[i] = i

    move_amount = 0
    # current_pos = 0
    # goal_pos = len(space_list) - 1
    # steps_to_goal = 9999
    solvable = True
    solution_found = False
    print(space_list)
    print(steps_away)
    while solvable and not solution_found:
        steps_away[len(space_list)-1] = 0
        for i in reversed(range(0, len(space_list))):
            # print(f"\nChecking the spaces before {i}")
            # print(f"Spaces before:", end="")
            for j in reversed(range(space_list[i] - get_reverse_range(space_list[i]), space_list[i])):
                # print(f"{j}({space_list[j]}),", end="")
                if steps_away[i] != -1:
                    if space_list[j] == j:

                        print(
                            f"Setting {j}-{steps_away[j]} to {steps_away[i]+1} ({i}-{steps_away[i]})")
                        if steps_away[i] + 1 < steps_away[j] or steps_away[j] == -1:
                            steps_away[j] = steps_away[i] + 1
                        if i == 10:
                            print(f"j:{j}")
                            print(f"j:{j}")
                            print(f"space j {space_list[j]}")
                            print(f"steps_away[j] is now {steps_away[j]}")
                            print(steps_away)
                            print(space_list)
                            stop = input()
                    else:
                        if space_list[j] > j:
                            print(f"j:{j}")
                            print(f"j:{j}")
                            print(f"space j {space_list[j]}")
                            print(
                                f"Setting {j}-{steps_away[j]} to {steps_away[space_list[j]]+1} ({space_list[j]}-{steps_away[space_list[j]]})")
                            if steps_away[space_list[j]] + 1 < steps_away[j] or steps_away[j] == -1:
                                steps_away[j] = steps_away[space_list[j]] + 1
                            if i == 10:
                                print(f"steps_away[j] is now {steps_away[j]}")

                                print(steps_away)
                                stop = input()

        for i in reversed(range(0, len(space_list))):
            print(f"{space_list[i]}-", end="")
        print("test")
        solution_found = True
        move_amount = 0

    print(steps_away)
    if solvable:
        return steps_away[0]
    else:
        return -1


def snakesAndLaddersDraft(board):
    # make board into line
    # for all the board spots, go through and put into one array in order

    space_list = []
    for i in reversed(range(0, len(board))):
        if i % 2 != len(board) % 2:
            # print(f"Adding row{i} left to right")
            for j in range(0, len(board[i])):
                space_list.append(board[i][j])
        else:
            # print(f"Adding row{i} right to left")
            for j in reversed(range(0, len(board[i]))):
                space_list.append(board[i][j])
    # stop = input()

    # fix values to match up with array index
    for i in range(0, len(space_list)):
        if space_list[i] > 0:
            space_list[i] -= 1
        else:
            space_list[i] = i
    print(space_list)
    # for i in range(0, len(space_list)):
    #     print(space_list[i])
    #     stop = input()

    # nok* to find shortest path
    # algorithm to jump steps where possible
    # if snake, check snake end, if ladder within 6 spaces, AND ladder leads at least 12 spaces ahead of current position.
    # if ladder, check if end of ladder is more than 6 spaces from current position
    move_amount = 0
    current_pos = 0
    steps = []
    goal_pos = len(space_list) - 1
    print(f"bot is at {current_pos} and wants to get to {goal_pos}")
    stop = input()
    solvable = True
    while current_pos < goal_pos and solvable:
        print("##########NEW MOVE##########")
        move_amount += 1
        print(f"##Current position: {current_pos} ##")
        # find maximum value for each step, one levels deep
        highest_value = 0
        highest_value_index = 0
        lowest_steps_for_highest = 100
        one_step_highest_value = 0
        one_step_highest_value_index = 0
        two_step_highest_value = 0
        two_step_highest_value_index = 0
        three_step_highest_value = 0
        three_step_highest_value_index = 0
        check_range = get_range(current_pos, goal_pos)
        for i in reversed(range(current_pos + 1, current_pos+check_range)):
            if space_list[i] >= one_step_highest_value:
                one_step_highest_value = space_list[i]
                one_step_highest_value_index = i
                lowest_steps_for_highest = 1
                if space_list[i] >= highest_value:
                    highest_value = space_list[i]
                    highest_value_index = i
            check_range_level_2 = get_range(space_list[i], goal_pos)
            print(f"Checking index {i}({space_list[i]}), which reaches:")
            for j in reversed(range(space_list[i] + 1, space_list[i] + check_range_level_2)):
                if current_pos == 26:
                    print(f"")
                if space_list[j] >= highest_value and space_list[j] > one_step_highest_value:
                    highest_value = space_list[j]
                    highest_value_index = i

                if space_list[i] != space_list[j]:
                    if space_list[j] > two_step_highest_value:
                        two_step_highest_value = space_list[j]
                        two_step_highest_value_index = j
                    # print(f"{space_list[j]}")
                    print(
                        f"###{j}({space_list[j]}), which reaches:\n  -", end="")
                    check_range_level_3 = get_range(space_list[j], goal_pos)
                    for y in reversed(range(space_list[j] + 1, space_list[j] + check_range_level_3)):
                        print(f"{space_list[y]},", end="")
                        if space_list[y] > highest_value and space_list[y] > one_step_highest_value:
                            highest_value = space_list[y]
                            highest_value_index = i
                        print(f"y before if:{y}")
                        print(f"y value before if:{space_list[y]}")
                        print(f"goal before if:{goal_pos}")
                        if space_list[y] < goal_pos:
                            check_range_level_4 = get_range(
                                space_list[y], goal_pos)
                            print(f"check_range_4:{check_range_level_4}")
                            for x in reversed(range(space_list[y] + 1, space_list[y] + check_range_level_4)):
                                # if current_pos == 26 and space_list[x] > 130:
                                #     print(
                                #         f"((Inside last loop {space_list[x]}))")
                                print(f"len(space_list): {len(space_list)}")
                                print(f"i:{i}")
                                print(f"j:{j}")
                                print(f"y:{y}")
                                print(f"x:{x}")
                                if space_list[x] > highest_value and space_list[i] != space_list[j] and space_list[y] != space_list[j] and space_list[y] != space_list[x]:
                                    highest_value = space_list[x]
                                    highest_value_index = i

                print("")
            print("")
        print(
            f"Best move is to space {highest_value_index}({space_list[highest_value_index]}), which takes us to {highest_value} within four moves")

        # print(goal_pos - current_pos > 6)
        # print(goal_pos - current_pos)
        # print(highest_value)
        # print(one_step_highest_value)
        if two_step_highest_value <= one_step_highest_value and goal_pos - current_pos > 6 and two_step_highest_value <= 6:
            print("not solvable")
            solvable = False

        current_pos = space_list[highest_value_index]
        if one_step_highest_value > highest_value:
            current_pos = space_list[one_step_highest_value_index]
        steps.append(current_pos)
        # stop = input(f"")
        print(f"Steps taken: {steps}")

    if solvable:
        return move_amount
    else:
        return -1


def get_reverse_range(current):
    range = 6
    if current < 6:
        range = current
    return range


def get_range(current, max):
    range = 7
    if (max - current < 7):
        range = max - current + 1
    return range


    # Testing
for i in range(0, len(test_cases)):
    result = snakesAndLaddersRework(test_cases[i])
    if result == expected_results[i]:
        print(f"==Test case {i+1} was valid")
        print(f"✔️ {result} moves, expected {expected_results[i]}")
    else:
        print(f"==Test case {i+1} was INVALID")
        print(f"❌ {result} moves, expected {expected_results[i]}")
    stop = input(f"")
